1.对于简单的使用，只需配置cassandra.yaml文件:
	(1) 集群名称cluster_name：同一个集群中的集群名称应该一样。
	(2) 数据存放路径data_file_directories：可以根据情况配置一个有写权限的路径
	(3) commit log路径commitlog_directory：同上
	(4) saved cache路径saved_caches_directory：同上
	(5) 日志文件路径log4j.appender.R.File：同上（这个选项在log4j-server.properties文件中）

	此外，还需要修改服务监听的地址和thrift访问地址，即ListenAddress和ThriftAddress，配置文件默认监听的都是localhost：
	<!-- Cassandra节点之间通信的监听地址，这里设置所在节点的ip-->
	ListenAddress = 100.200.3.1
	Thrift监听的地址，建议设置为0.0.0.0
	ThriftAddress = 0.0.0.0
	经过上面的配置就可以启动节点了：
	进入bin目录，直接执行：./cassandra
	
2. Cassandra多个节点安装
	配制seeds。Cassandra没有传统集群的中心节点，各个节点地位都是平等的，通过Gossip协议维持集群中的节点信息。为了使集群中的各节点在启动时能发现其他节点，需要指定种子节点（seeds），各节点都先和种子节点通信，通过种子节点获取其他节点列表，然后和其他节点通信。种子节点可以指定多个，通过在 conf/ cassandra.yaml中的seeds属性配置
	seeds:
	- 100.200.3.81
	- 100.200.3.78

3. Cassandra附带工具使用方法介绍

	bin目录下自带了很多工具，可以帮助用户很方便地进行一些操作。常用的工具有nodetool，cassandra-cli，sstable2json等
	(1) nodetool
	nodetool是一个cassandra集群管理工具，这里只简单介绍一些简单的命令，详细的命令可以参见工具的帮助信息。

	ring命令
	ring命令用于查看集群的节点信息，ring来源于consistent hash，在consistent hash中，各个节点组成一个环，通常称为ring。

	Info命令
	info可以参看某个节点负载，内存使用情况：

	cfstats命令
	cfstats命令可以查看各个CF的详细统计信息，包括读写次数、响应时间、memtable信息等。

	(2) cassandra-cli
	cassandra-cli是一个命令行工具，可以用于对数据库进行数据查询和检索。具体可参见这篇文章：

	(3) sstable2json
	将sstable中的数据转化为json格式，使用方法为：

	Usage: sstable2json [-f outfile] <sstable> [-k key [-k key [...]]]

4.  Cassandra的三大接口 thrift hector binary memtable
	参考文章：http://hi.baidu.com/diwulechao/blog/item/d8f0abcd6285ea0801e928c7.html/cmtid/afafbab6edc733e431add1c0
	
	Cassandra目前已知的接口有3个：Thrift  Hector  BinaryMemTable

	（1）Apache Thrift

		优点：简单高效
		缺点：功能简单，无法提供连接池，错误处理等功能，不适合直接在生产环境使用。

	（2）Hector

		Hector是基于Thrift Java API包装的一个Java客户端，提供一个更加高级的一个抽象。更加有利于程序员编程，在实际应用环境下推荐使用。

		优点：
			提供连接池。
			提供错误处理：当操作失败的时候，Hector会根据系统信息（token map）自动连接另一个Cassandra Service。
			编程接口容易使用。
			支持JMX。

 		缺点：
			不支持多线程的环境。
			keyspace封装过多（数据校验和数据重新封装），如果进行大量的数据操作，这里的消耗需要考虑。
			错误处理不够人性化：如果所有的Cassandra Service都非常繁忙，那么经过多次操作失败后，最终的结果失败。

	（3）Binary Memtable
		Hector相比较Thrift更加人性化，但是在导入大量数据的时候这会遇到很多的问题，比如插入失败，超时等等。于是就诞生了Binary Memtable，它是Cassandra的大容量读写接口，它避免了以下几种当使用普通的Thrift接口时可能会产生的额外开销：
			内部数据结构和Thrift数据结构的相互转换时的开销。
			复制指定的数据节点的开销。
			记录到日志文件的开销。
			将内部数据结构转换为存储介质格式时的开销。

		Binary Memtable最大的缺点在于它并不是基于Thrift的API。它跟Thrift一样是基于StorageProxy的API。它绕开了Thrift，所以从接口效率上他比以上两种都更优。但它的缺点是显著的：
		必须使用StorageProxy的API，也就是说只能用Java进行编写。Apache对使用StorageProxy API提出了再三警告。（原句为so using it directly provides some efficiency gains - but please think twice before using it, and be sure that you really need to before doing so.）

		必须自己对行序列化（在前两种接口中，行是系统自动排序的）
		一次必须写入一整行。

		从以上几点可以看出，Binary Memtable是基于比Thrift更加底层的文件读写接口，完完全全的绕开了Cassandra的各种机制。从效率上说肯定更优。但是如果没有对Cassandra的内部处理机制有着烂熟于心的理解，不推荐使用。


